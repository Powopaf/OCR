\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage[french]{babel} % pour dire que le texte est en fran¸cais
\usepackage{a4} % pour la taille
\usepackage[T1]{fontenc} % pour les font postscript
\usepackage[cyr]{aeguill} % Police vectorielle TrueType, guillemets fran¸cais
\usepackage{amsmath, amsthm} % tr`es bon mode math´ematique
\usepackage{float} % pour le placement des figure
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage{makecell}
\usepackage{hyperref}
\usepackage{amssymb}
%\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{graphicx}
\graphicspath{ {./} }
\pagestyle{fancy}
\usepackage{animate}
\usepackage[utf8]{inputenc}
\def\checkmark{\tikz\fill[scale=0.4](0,.35) -- (.25,0) -- (1,.7) -- (.25,.15) -- cycle;} 
%pour drawn le neural network
\usepackage{tikz}
\usetikzlibrary{positioning}
\tikzset{%
  every neuron/.style={
    circle,
    draw,
    minimum size=1cm
  },
  neuron missing/.style={
    draw=none, 
    scale=4,
    text height=0.333cm,
    execute at begin node=\color{black}$\vdots$
  },
}

\usepackage{minted}
\usepackage{listings}
\lstset{language=C, basicstyle=\ttfamily, keywordstyle=\color{blue}, commentstyle=\color{green}}
\usepackage{xcolor}
\fancyhf{}

\definecolor{bgcolor}{rgb}{0.7,0.7,0.7}
\definecolor{stringcolor}{rgb}{0.58,0,0.82}
\definecolor{keywordcolor}{rgb}{0.10,0.10,0.80}
\definecolor{commentcolor}{rgb}{0.0,0.6,0.0}

\lstset{
  backgroundcolor=\color{bgcolor},
  basicstyle=\ttfamily,
  frame=single,
  framerule=0.5pt,
  rulecolor=\color{black},
  xleftmargin=3pt,
  xrightmargin=3pt,
  breaklines=true,
  keywordstyle=\color{keywordcolor}\bfseries,
  stringstyle=\color{stringcolor},
  commentstyle=\color{commentcolor},
  numbers=left,
  numberstyle=\tiny\color{gray},
  language=[Sharp]C
}

\begin{document}
\title{ \HUGE \textbf{ \includegraphics[scale=0.25]{icon_black.png}}
		\\ [2.0cm]
		\Xhline{2pt} \\
        [0.5cm]
		\LARGE \uppercase{Projet OCR CLAPS}\\
        [0.5cm]
		\Xhline{2pt} \\ 
        [4cm]
		\textsc{Rapport de Soutenance 1}}
  
\author{
    Coureau Adrien\\
    Del-Pozo Corentin\\
    Fournier Pierre-Antoine\\
    Lou Sophie\\
}
\date{}
\maketitle
\newpage
\large
\pagestyle{fancy}
\cfoot{\thepage}
\tableofcontents
\pagebreak

\lhead{}
\rhead{\textbf{Projet Word Search OCR}}
\lfoot{\textbf{Groupe CLAPS}}
\rfoot{\textbf{EPITA}}

\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}
\section{Introduction}
\paragraph{}
Tout au long du projet CLAPS Word Search OCR, la présence d’un rapport de projet est primordiale. Il nous permettra de nous concentrer sur le bilan de ce qui a été fait et la manière dont nous allons traiter le projet sur le temps imparti (du mois de septembre au mois de décembre).
Nous présenterons ainsi l’état d’avancement de notre projet, ainsi qu’un compte rendu qui détaillera les tâches prévues dans le cahier des charges.
\paragraph{}
L’objectif de ce projet est de nous offrir la possibilité de mettre en oeuvre de manière concrète, les connaissances acquises en cours. Cela nous donnera ainsi l’occasion d’augmenter nos acquis personnels nécessaires au projet.
\paragraph{}
Le but final de ce projet est de réaliser un logiciel de type OCR qui résout une grille de mots cachés en 3 mois. Notre application prendra donc en entrée une image représentant une grille de mots cachés et affichera en sortie la grille résolue.
\paragraph{}
Ainsi, nous avons découpé ce projet en plusieurs parties:\\
\begin{itemize}
    \item Reconnaissance des caractères (réseau de neurones)\\
    \item Résolution d’une grille de mots cachés (solver)\\
    \item Prétraitement de l'image \\
    \item Interface graphique \\
\end{itemize}
\newpage
\section{Répartition des Tâches}
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
    \hline Tâches & Pierre-Antoine & Corentin &  Adrien & Sophie\\
    \hline Interface Utilisateur & & &\checkmark & \\
    \hline Niveau de gris & \checkmark & & & \\
    \hline Réduction de bruits & \checkmark & & & \\
    \hline Rotation & & & &\checkmark \\
    \hline Binarisation & &  & \checkmark & \\
    \hline Détection de Grille & & \checkmark & & \\
    \hline Solver & &  & & \checkmark \\
    \hline Réseaux de Neurones & & \checkmark & & \\
    \hline
\end{tabular}
\end{center}

\section{Avancement}
\begin{center}
\begin{tabular}{|c|c|c|}
    \hline Tâches & 04/10/2024 & 09/12/2024 \\
    \hline Interface Utilisateur & 60\% & 100\% \\
    \hline Niveau de gris & 100\% & 100\% \\
    \hline Réduction de bruits & 50\% & 100\% \\
    \hline Rotation & 50\% & 100\% \\
    \hline Binarisation & 100\% & 100\%     \\
    \hline Détection de Grille & 70\% & 100\% \\
    \hline Solver & 100\% & 100\% \\
    \hline Réseaux de Neurones & 50\% & 100\% \\
    \hline
\end{tabular}
\end{center}
\section{Notre Equipe}
\subsection{Lou Sophie}
\paragraph{}
Animée par mon attirance pour les mathématiques, la réalisation de la rotation manuelle d’image, m’a permis de nourrir cette curiosité, par l’application à des choses concrètes et visuelles (ici, des grilles de mots mêlées). Le fait d’avoir l’occasion de mettre en pratique des connaissances mathématiques, pouvant paraître abstraites, en l’associant à de l’informatique, m’a rappelé l’importance de ces deux domaines.
\paragraph{}
De plus, en mettant en place un algorithme de Solver, cela m’a permis de comprendre l’implémentation d’un algorithme de résolution de mots cachés. 
Ensemble, nous avons pu déterminer quel était le plus efficace à implémenter.
Toujours en quête d’application concrète, le fait de savoir de manière immédiate si un mot a été trouvé ou non, était très encourageant.
\newpage
\subsection{Fournier Pierre-Antoine}
\paragraph{}
Pour ce projet, j’ai choisi de faire les niveaux de gris et la réduction de bruit car le traitement d’image m’intéresse. De plus, j'envisage de faire la majeur des images à EPITA. Ce projet est donc un bon moyen de découvrir si le traitement d'images me plaît. 
\subsection{Del-Pozo Corentin}

Pour ce projet, j'ai choisi de m'occuper du réseau de neurones, car c'est un sujet en informatique qui me passionne beaucoup. Avant de commencer le projet, je m'étais déjà renseigné sur son fonctionnement et sur toutes les possibilités qu'il offre. Le développement du réseau de neurones m'a permis d'approfondir mes connaissances en apprentissage supervisé et d'appliquer des concepts théoriques à des problèmes pratiques. Cela m'a également permis de mieux comprendre comment les algorithmes peuvent apprendre et s'adapter à des données variées, ce qui est essentiel dans le contexte de l'intelligence artificielle.
\\

En ce qui concerne la détection de la grille, j'ai choisi de m'occuper de ce problème parce qu'au début, notre groupe n'avait aucune idée de quelle direction prendre. J'apprécie particulièrement les défis qui consistent à chercher des solutions dans un environnement où nous disposons de peu d'indices et de ressources. Cette contrainte nous pousse à développer nos propres solutions et à faire preuve de créativité, ce qui rend le processus d'apprentissage d'autant plus stimulant.

\subsection{Coureau Adrien}
\paragraph{}
Passionné d'informatique depuis petit, l'univers de la création m'attire beaucoup (dessin, dessin digital, production de musique). J'ai choisi de développer l'interface du projet en gtk3 avec l'aide de Glade parce que j'aime créer un produit fini et cohérent à partir de zéro.
\paragraph{}
La conception d'une interface facile à prendre en main est cruciale pour fluidifier l'expérience de l'utilisateur ainsi que renforcer la rapidité des tâches et des tests pour les développeurs. Elle est la liaison entre ce que l'on voit, les boutons, et toutes les actions que peut effectuer notre application d'OCR.
\newpage
\section{Pourquoi le format BMP}
\paragraph{}
Nous avons choisi ce format car il rend plus simple le parcours d’une image, tout en conservant une bonne qualité avec ce format. Cependant, il est plus volumineux que le format \texttt{PNG}, il est donc important de supprimer toutes les images en \texttt{BMP} que nous avons créées avant un éventuel crash. Pour cela, un script suffit. Nous devons aussi convertir l’image fournie par l’utilisateur avant d’effectuer toute opération.

\subsection{Parcourir une image BMP}
\paragraph{}
Pour faire un parcours d’une image, il nous suffit d’appeler la fonction 
\begin{lstlisting}
   SDL_LoadBMP("img.bmp")
\end{lstlisting}
qui renvoie une \texttt{surface}. La \texttt{surface} est une structure de la librairie \texttt{SDL} qui contient la hauteur, la largeur et le pointeur vers le tout premier pixel de l’image.
\paragraph{}
L’image est contenue dans un seul tableau : les 3 premières valeurs sont les pixels rouge, vert, et bleu du premier pixel, puis les 3 suivantes ceux du second et ainsi de suite. \\
Pour parcourir une image nous utilisons le code suivant :
\begin{lstlisting}
for (int i = 0; i < height; i++) 
{
    for (int j = 0; j < width; j++) 
    {
        Uint8* pixel = pix + j * pitch + i * bpp;
        // do stuff on the image
    }
}
\end{lstlisting}
Nous avons une double boucle plutôt classique. Ensuite, pour récupérer un pointeur vers la couleur rouge du pixel actuel, il nous suffit de faire le calcul suivant :
\\
\texttt{pix} est le pointeur du tout premier pixel de l’image, accessible avec \texttt{surface→pixels}. On lui ajoute \texttt{i} qui correspond à la rangée horizontale actuelle multipliée par le \texttt{pitch} (accessible via \texttt{surface→pitch}). Le \texttt{pitch} est le nombre d'octets entre les lignes. Il n’est pas toujours égal au nombre de pixels multiplié par le nombre d'octets par pixel (\texttt{bpp}), car des octets peuvent être ajoutés en bout de ligne pour des raisons de performance. Ainsi, \texttt{pix + i * pitch} nous permet de récupérer la bonne ligne de pixels de l’image. Nous ajoutons \texttt{j}, correspondant au \texttt{j}-ème pixel de la \texttt{i}-ème rangée, et nous multiplions \texttt{j} par le nombre d'octets par pixel (\texttt{surface→format→BytesPerPixel}). Dans notre cas, \texttt{BytesPerPixel} vaut 3.

\section{Réduction de Bruit}
\paragraph{}
Dans les images données dans le cahier des charges, le niveau 2 contient des images avec du bruit. Nous avons implémenté deux algorithmes pour réduire le bruit : le flou médian et le flou Gaussien. Pour simplifier les algorithmes, nous appliquons un "grayscale" car les valeurs des trois couleurs (RGB) sont égales.

\subsection{Le flou médian}
Le flou médian consiste à placer dans une liste les 8 valeurs des pixels autour, puis à prendre la valeur du milieu pour l’attribuer au pixel actuel. Nous utilisons un tri par insertion pour ranger les valeurs. À noter qu’il est possible d’élargir le noyau de \texttt{3x3} à un noyau de \texttt{5x5}. Cet algorithme permet d’éliminer les pixels ayant une valeur très différente des pixels proches, tout en conservant les contours, ce qui est pratique pour préserver la forme des lettres.

\subsection{Le Flou Gaussien}
Le flou Gaussien utilise également un noyau, mais il est prédéfini. On peut choisir sa taille (\texttt{3x3}, \texttt{5x5}, …), et dans notre cas nous utilisons un noyau de taille \texttt{3x3}. Pour calculer les valeurs du noyau, nous appliquons la fonction Gaussienne, qui produit une courbe similaire à l'image fournie (elle peut être plus pentue ou plus allongée).
%image courbe gauss
\paragraph{}
Les valeurs fournies à la fonction Gaussienne, qui prend trois arguments, sont \texttt{X} et \texttt{Y}, représentant respectivement les coordonnées (\texttt{x, y}) des pixels autour du milieu du noyau de coordonnées (\texttt{0,0}). Le troisième argument est \texttt{sigma}, qui permet d'ajuster la luminosité de l’image. Pour déterminer le \texttt{sigma} optimal, nous avons testé plusieurs valeurs croissantes pour trouver la meilleure. La fonction est la suivante :
$$
\mathcal{G}(x,y) = \frac{1}{2\pi\sigma^2}\exp^{-\frac{x^2+y^2}{2\sigma^2}} \mbox{~et~} \sigma \in \mathbb{R}
$$
\begin{lstlisting}
#define M_PI        3.14159265358979323846

double gFunc(int x, int y) 
{
    const double sig = 0.58;
    double part1 = 1 / (2 * M_PI * sig * sig);
    double power = -(x * x + y * y) / (2 * sig * sig);
    double part2 = exp(power);
    return part1 * part2;
}
\end{lstlisting}

\subsection{Contraste}
Nous avons aussi utilisé un algorithme de contraste d’image pour accentuer le noir et le blanc sur les images avant d’appliquer les algorithmes de réduction de bruit. Le contraste fonctionne de la manière suivante :\\
On construit une liste des 8 pixels autour du pixel actuel et on compare ensuite avec la condition suivante :
\begin{lstlisting}
// sidepixel is an array containing the 8 pixels around pixel
if (side_pixel[k] < pixel[0] && pixel[0] < 200) { /*...*/ }
\end{lstlisting}
Si cette condition est validée, on retire 50 à la valeur actuelle du pixel. 
Voici quelques exemples avant et après l’application de notre algorithme :
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{img6.png}
    \caption{Avant}
    \includegraphics[scale=0.3]{img7.png}
    \caption{Après}
\end{figure}

\newpage
\section{Rotation de l'image}
\paragraph{}
Plusieurs méthodes peuvent être appliquées afin d’effectuer une rotation d’image. Voici deux techniques testées, menant à celle retenue pour ses meilleures performances.

\subsection{Rotation avec une seule matrice}
\paragraph{}
Cette méthode de rotation utilise la formule suivante :
$$
x' = \cos(\theta) * x - \sin(\theta) * y
$$
$$
y' = \sin(\theta) * x + \cos(\theta) * y
$$
\paragraph{}
qui provient de la représentation matricielle suivante :\\
$$\left( \begin{array}{cc} x' \\ y'\end{array}\right) = \left( \begin{array}{cc} \cos(\theta) & \sin(\theta) \\ -\sin(\theta) & \cos(\theta) \end{array}\right)\left(\begin{array}{cc} x \\ y\end{array}\right)$$ 
\\\\
(avec \(\theta\) l’angle en degré)

\subsubsection{Problème rencontré}
\paragraph{}
Malgré la simplicité de cette formule, son application provoque des problèmes d'aliasing dus à l’apparition non voulue de points noirs, nuisibles à la détection des lettres. La rotation avec une seule matrice affecte donc la qualité de l’image, en raison d’une mauvaise utilisation. En effet, nous sommes partis des coordonnées des pixels de l'image d'origine et avons calculé leur position après rotation dans la nouvelle image. Cette technique s’appelle l'échantillonnage en avant, avec pour effet de laisser des trous dans l’image.
\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{img1.png}
    \caption{Problème 1}
\end{figure}

\subsection{Rotation par cisaillement}
\paragraph{}
Ne sachant pas que le problème rencontré était dû à une mauvaise utilisation, nous avons voulu appliquer le principe de rotation par cisaillement (aussi appelé rotation par \texttt{Shearing}), qui utilise l’algorithme de \texttt{Shearing}, prenant chaque pixel de l’image et appliquant trois multiplications successives avec des matrices utilisant l’angle \(\theta\) en radian. \\
Elle utilise la représentation matricielle suivante :
$$
\left(\begin{array}{cc} x' \\ y' \end{array}\right) = \left(\begin{array}{cc}
   1  & -\tan(\frac{\theta}{2}) \\
    0 & 1 \end{array}\right) \times \left(\begin{array}{cc} 1 & 0 \\ \sin(\theta) & 1 \end{array}\right) \times \left(\begin{array}{cc} 1 & -\tan(\frac{\theta}{2}) \\ 0 & 1 \end{array}\right)
   \left(\begin{array}{cc} x \\ y \end{array}\right)
$$

\subsection{Détection des formes}

Nous commençons par détecter tous les amas de pixels blancs connectés entre eux, en utilisant un algorithme similaire à celui du "pot de peinture" des logiciels de dessin, qui parcourt l'image de manière récursive.
\\\\
Deux matrices sont créées : l'une pour indiquer si un pixel a été visité et à quelle forme il appartient, et une autre qui stocke l'image sous forme de 1 (pixels noirs) et 0 (pixels blancs), afin de faciliter la distinction des pixels blancs et noirs dans la fonction récursive.
\\\\
L'algorithme parcourt toute l'image et, dès qu'un pixel blanc non visité est trouvé, il initialise une nouvelle forme.

\noindent Structure de la forme :
\begin{lstlisting}
typedef struct Shape 
{
    int id; // Identifier of the shape
    int Cx, Cy; // Coordinates of the center of the shape
    int h, w; // Height and width of the shape

    // Coordinates of the edges of the shape
    int Maxj, Maxi;
    int Minj, Mini;

    int Matj, Mati; // Coordinates of the letter in the grid

    int Len; // Number of pixels in the shape
} Shape;

\end{lstlisting}

\vspace{0.5cm}
\newpage
Un identifiant unique est attribué à chaque forme, puis l'algorithme parcourt récursivement les quatre pixels directement adjacents. Pour chaque pixel visité, sa valeur dans la matrice de vérification est remplacée par l’identifiant de la forme. Cette opération est répétée pour les pixels adjacents suivants.
\\\\
Une fois la forme entièrement détectée, des informations comme le nombre de pixels constituant la forme ainsi que sa largeur et sa hauteur sont stockées.
\\\\
Ensuite, un premier tri est effectué pour éliminer les formes trop grandes, par exemple celles qui occupent plus de la moitié de la taille de l'image.

Si une forme est valide, elle est ajoutée à la liste des formes. Pour cet algorithme, nous avons implémenté une structure de liste chaînée pour faciliter la manipulation des formes trouvées.
\\\\
Structure de la liste chaînée :
\begin{lstlisting}
typedef struct Node
{
    Shape* data;
    struct Node* next;
} Node;
\end{lstlisting}

\vspace{0.5cm}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{imgFindShape_1.png}
    \caption{Image après la détection des formes}
\end{figure}

\subsection{Filtrage des formes}

Une fois toutes les formes détectées, on filtre les formes non valides pour garder uniquement les lettres. Pour cela, nous calculons la somme de la largeur, de la hauteur et de la taille de toutes les formes, puis supprimons celles qui s'écartent trop de la moyenne. Ce filtre permet d’éliminer les formes trop petites.
\\\\
En calculant la moyenne des hauteurs, on obtient la taille moyenne de la police, un paramètre efficace pour le filtrage.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{imgShapeFilter_1.png}
    \caption{Image après le filtrage des formes}
\end{figure}

\subsection{Détection des groupes}

À ce stade, la plupart des formes sont des lettres, mais certaines formes invalides peuvent subsister. Nous passons à la détection des groupes et filtrerons les groupes invalides.
\\\\
Pour détecter les groupes, nous parcourons chaque forme et vérifions plusieurs critères :
\begin{itemize}
    \item La distance entre deux formes est-elle suffisamment petite par rapport à la taille de la forme ?
    \item La hauteur de la forme est-elle proche de la moyenne des hauteurs des formes dans le groupe ?
\end{itemize}
\vspace{0.5cm}
Pour chaque forme assez proche, on vérifie qu'elle n'appartient pas déjà à un autre groupe en consultant une liste de formes rencontrées. Si elle est inédite, nous l’ajoutons au groupe et à la liste des formes visitées.
\\\\
Les groupes sont des listes chaînées de formes.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{imgFindCluster_1.png}compare/latex-adrien?expand=1
    \caption{Image après la détection des groupes}
\end{figure}

\subsection{Filtrage des groupes}

Une fois tous les groupes créés, nous appliquons un filtre pour ne conserver que les groupes de mots ou de lettres. Pour cela, nous calculons la taille moyenne des groupes, définie par la somme des tailles de chaque forme contenue, puis éliminons ceux en dessous de cette moyenne.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{imgClusterFilter_1.png}
    \caption{Image après le filtrage des groupes}
\end{figure}

Après le filtre, nous supposons que le plus grand groupe est la grille, les autres groupes représentant les mots.

\subsection{Récupération des lettres}

Avec seulement les groupes de mots ou de lettres conservés, nous parcourons chaque groupe pour en extraire les lettres et les sauvegarder sous forme d'images dans un dossier par groupe, en vue d’un traitement ultérieur avec le réseau de neurones.
\\\\
Pour ce faire, nous utilisons la matrice de pixels déjà visités. Nous parcourons cette matrice entre les coordonnées de début et de fin de la forme dans la structure Shape. Pour chaque élément contenant l'identifiant de la forme, nous reportons ce pixel dans une nouvelle image aux dimensions de la lettre, sauvegardée dans un dossier dédié.
\newpage
\section{Réseau de neurones}

Notre réseau de neurones suit une structure classique avec une couche d’entrée, une couche cachée et une couche de sortie. Le nombre de nœuds par couche varie selon l'application, comme le XOR ou le traitement d'image.

\subsection{XOR}
% Schéma du réseau de neurones pour le XOR
\begin{tikzpicture}[x=2cm, y=2cm, >=stealth]

\foreach \m/\l [count=\y] in {1,2}
  \node [every neuron/.try, neuron \m/.try] (input-\m) at (0,1.5-\y) {};

\foreach \m [count=\y] in {1,2,3}
  \node [every neuron/.try, neuron \m/.try ] (hidden-\m) at (2,2.5-\y*1.25) {};

\foreach \m [count=\y] in {1}
  \node [every neuron/.try, neuron \m/.try ] (output-\m) at (4,1-\y) {};

\foreach \l [count=\i] in {0,1}
  \draw [<-] (input-\i) -- ++(-1,0)
    node [above, midway] {$\l$};

\foreach \l [count=\i] in {1,2,3}
  \node [above] at (hidden-\i.north) {$H_\l$};

\foreach \l [count=\i] in {1}
  \draw [->] (output-\i) -- ++(1,0)
    node [above, midway] {$\l$};

\foreach \i in {1,2,2}
  \foreach \j in {1,2,3}
    \draw [->] (input-\i) -- (hidden-\j);

\foreach \i in {1,2,3}
  \foreach \j in {1}
    \draw [->] (hidden-\i) -- (output-\j);

\foreach \l [count=\x from 0] in {Input, Hidden, Output}
  \node [align=center, above] at (\x*2,2) {\l \\ layer};
\end{tikzpicture}

\section{Solver}
Pour résoudre le mot mêlé, on récupère la grille de lettres dans un fichier texte généré par le code. Cette grille est ensuite stockée dans une matrice de caractères.

\begin{description}
    \item[Étape 1] Trouver la première lettre : on parcourt la grille jusqu'à la première lettre du mot.
    
    \item[Étape 2] Trouver la deuxième lettre : une fois la première lettre trouvée, on recherche la deuxième dans les 8 cases adjacentes. Si elle est trouvée, on détermine la direction pour le reste des lettres.
    
    \item[Étape 3] Trouver le reste du mot : en vérifiant que le mot peut tenir dans la direction sans dépasser les limites de la grille, on parcourt chaque lettre restante du mot.
\end{description}
Grâce à cet algorithme, on est certain de trouver le mot s'il existe dans la grille et d'en renvoyer les coordonnées. Ces informations seront très utiles plus tard pour indiquer visuellement l'emplacement de chaque mot dans la grille.
\clearpage
\section{Interface}
La création d'une interface cohérente et simple à utiliser est cruciale pour fluidifier l'expérience utilisateur. Elle a constitué une part importante du travail à effectuer sur le projet. L'interface est la liaison entre ce que voit l'utilisateur de notre logiciel et le traitement appliqué pour trouver la solution finale du problème initial.\\

\subsection{Du concept...}
La première étape a été de conceptualiser l'interface visuelle à l'aide du logiciel \texttt{Glade}. Notre objectif était de concevoir un ensemble simple avec uniquement des boutons à gauche pour modifier les paramètres de traitement, ainsi qu'une image à droite pour visualiser la solution et toutes les étapes qui ont mené à cette solution.\\

L'interface est donc composée d'une colonne de paramètres modifiables à gauche et d'une image dynamiquement modifiée à droite.\\

Dans la colonne de gauche, on retrouve différentes sections :
\begin{itemize}
    \item Un titre et un logo créés par notre équipe, montrant à la fois deux mains qui s'entrechoquent pour le nom \texttt{CLAPS} ainsi qu'un petit robot analyseur pour symboliser la partie intelligence artificielle du projet.
    \item Un bouton pour importer depuis les fichiers de l'ordinateur une image à faire traiter par notre \texttt{OCR}. Celle-ci peut être modifiée à tout moment.
    \item Un curseur pour ajuster la rotation manuelle de l'image originale entre \texttt{-90} et \texttt{+90} degrés. Un bouton est également présent pour réinitialiser la valeur du curseur à \texttt{0}.
    \item Un bouton pour lancer le traitement de l'image. Celui-ci fait disparaître la section de rotation ainsi que sa propre section.
    \item Une série de boutons alternatifs pour sélectionner la visualisation de l'étape actuelle du traitement. Cela modifie dynamiquement l'image affichée à droite.
    \item Un bouton pour exporter l'image dans le format souhaité, à un emplacement sélectionné par l'utilisateur.\\
\end{itemize}

Dans la partie droite, on retrouve une image qui est modifiée en temps réel en fonction des actions de l'utilisateur. Par exemple, au lancement, il n'y a pas d'image, pendant la rotation, elle affiche l'image tournée, et lors de l'appui sur le bouton de traitement, elle affiche directement la solution du mot caché.\\

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.115]{ImgInterface_1.png}
    \caption{Interface avant le processus de traitement}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.115]{imgInterface_2.png}
    \caption{Interface après le processus de traitement}
\end{figure}

\subsection{... Au concret}
La deuxième étape a été de créer la liaison entre l'interface visuelle réalisée avec \texttt{Glade} et les fonctions codées dans le reste du projet, par l'intermédiaire de \texttt{GTK3}. \texttt{GTK} est par nature difficile à appréhender, car il est composé de dizaines de fonctions indépendantes du langage \texttt{C}.\\

Une fois la liaison créée, il a fallu faire fonctionner l'ensemble des éléments de l'interface.

L'image doit être facilement modifiable et doit conserver une taille adaptée à la hauteur de l'écran. Cela a été rendu possible grâce à \texttt{ImageMagick} et à son argument \texttt{-resize}, ainsi qu'à une implémentation dynamique de l'image.\\

Lors de l'importation d'une image, celle-ci doit être dupliquée et convertie en \texttt{.bmp} en deux exemplaires : l'un pour conserver la photo originale en cas d'exportation, et l'autre pour appliquer de potentielles rotations. Lors de l'appui sur le bouton de traitement, l'image doit être créée en 16 exemplaires différents : 8 pour l'exportation (l'image de l'étape \texttt{X} du traitement) en taille originale, et 8 autres pour l'affichage de l'image en taille redimensionnée, permettant ainsi de basculer rapidement entre les différents états une fois le traitement effectué, afin d'offrir l'expérience la plus fluide possible. Le traitement doit également créer un dossier d'images stockées sous le format \texttt{BMP} par cluster final, pour alimenter le réseau de neurones.\\

Le curseur de rotation, lors du relâchement de la souris après un appui, met à jour l'image stockée en lui appliquant la rotation du degré désiré. Lors de l'appui sur le bouton de réinitialisation, la valeur du curseur est remise à \texttt{0}, et l'image est remplacée par l'image originale.\\

Le bouton de traitement masque la section de rotation ainsi que sa propre section, pour laisser place aux boutons d'étapes et à la section d'exportation. Cependant, il conserve le bouton d'importation, qui reste accessible à tout moment pour changer l'image d'entrée, ce qui a pour effet de réinitialiser la visualisation des boutons.\\

Lorsqu'un bouton de sélection d'étape est activé, il met à jour l'image à droite et désélectionne le bouton actuellement activé, agissant ainsi comme un bouton alternatif parmi les autres boutons de sélection d'étapes.\\

Lors de l'appui sur le bouton d'exportation, une fenêtre de dialogue s'ouvre et permet de choisir un emplacement sur l'ordinateur pour sauvegarder l'image actuellement affichée dans son format original. Le nom par défaut est \texttt{solution.png}, mais il peut être modifié, ainsi que le format, grâce à l'outil \texttt{ImageMagick}, qui convertit automatiquement l'image dans le format souhaité en fonction de l'état actuel du traitement (\texttt{CurrentState}).\\

À la fermeture du programme ou lors de l'importation d'une nouvelle image, le logiciel supprime toutes les images temporaires présentes dans \texttt{/output/} ainsi que toutes les images de lettres présentes dans les sous-dossiers des clusters. Il termine enfin en fermant proprement l'interface \texttt{GTK}.\\
\newpage
\section{Conclusion}
\paragraph{}
Afin de cl\^oturer ce premier rapport de soutenance, nous pouvons \^etre fiers d'avoir pu r\'ealiser l'enti\`eret\'e de nos objectifs :
\begin{itemize}
    \item Chargement d'une image et suppression des couleurs 
    \item Rotation manuelle de l'image 
    \item D\'etection de la position : 
    \begin{itemize}
        \item De la grille
        \item De la liste de mots
        \item Des lettres dans la grille
        \item Des mots de la liste
        \item Des lettres dans les mots de la liste
    \end{itemize}
    \item D\'ecoupage de l'image (sauvegarde de chaque lettre sous la forme d'une image)
    \item Impl\'ementation de l'algorithme de r\'esolution d'une grille de mots cach\'es (solver)
    \item Une preuve de concept de votre r\'eseau de neurones (XOR)
\end{itemize}
\paragraph{}
Ayant toutes ces fonctionnalit\'es termin\'ees pour la premi\`ere soutenance, cela nous encourage \`a poursuivre dans cette voie, d\'emontrant une bonne organisation au sein du groupe.
\end{document}

